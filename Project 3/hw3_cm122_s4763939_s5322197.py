# -*- coding: utf-8 -*-
"""HW3 CM122 s4763939 s5322197.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iM0eP1i6M6dXyy0WCipe6gD2cavh3peo
"""

# Exercise 1 part a)

# function my_factorial is defined with input argument n.
def my_factorial(n):
    """
    This function calculates the factorial of an integer n.

    Input argument:
    n: (integer)    the integer to be evaluated

    Returns:
    factorial: (integer)    the factorial of the integer n
    """

    # if the input number is negative, the user is asked to provide a positive integer.
    if n < 0:
        print("The inputted number is negative. Please provide an integer greater than or equal to zero.")
        return
    # if n is 0, 1 is returned.
    elif n == 0:
        return 1
    # Otherwise, a for loop calculates the factorial of n and returns it.
    else:
        # output variable 'factorial' is initially set to the value of n.
        factorial = n
        # a for loop goes from n to 1 (step value -1) and calculates factorial.
        for i in range(n,1,-1):
            factorial *= (i-1)
        # 'factorial' value is returned.
        return factorial

# 'n' is set to the integer type of the user's input.
n = int(input("Input an integer: "))

# the factorial of n is printed through an f-string by calling my_factorial(n).
print(f"The factorial of the number is {my_factorial(n)}.")

# Commented out IPython magic to ensure Python compatibility.
# Exercise 1 parts b), c) and d)

# numpy package is imported for part c) of the exercise.
import numpy

# function taylor_expansion with input arguments k and x is defined.
def taylor_expansion(k,x):
    """
    This function calculates the Taylor expansion for a sine function.

    Input argument:
    k: (integer)    the number of terms in the expansion.
    x: (float)      the angle evaluated in radians.

    Returns:
    taylor: (float)    the taylor expansion of sin(x) with 'k' amount of terms.
    """

    # 'pi' is set to pi's value accurate to 12 significant figures.
    pi = 3.14159265359

    # if the number of terms is zero or negative, user is asked to provide a positive integer for k.
    if k <= 0:
        print("The inputted number of terms is negative or zero. Please provide an integer greater than or equal to one.")
        return

    # if the angle is negative, 2π is added to x until it is positive.
    elif x < 0:
        while x < 0:
            x += 2*pi

    # if the angle is greater than 2π, 2π is subtracted from it until it is less than 2π.
    elif x > 2*pi:
        while x > 2*pi:
            x -= 2*pi

    # once k and x have the right value, taylor is initially set to zero.
    taylor = 0

    # a for loop goes from 1 to k (number of terms) and adds the expansion of k terms to the taylor expansion ('taylor').
    for i in range(1,k+1):
        taylor += ((-1)**(i+1))*(x**((2*i)-1))/my_factorial((2*i)-1)
    # the value of the taylor expansion ('taylor') is returned
    return taylor

# k (number of terms) is set to the integer type of the user's input.
k = int(input("Input the number of terms in the Taylor expansion: "))

# 'new_line' is set to the string '\n' to make new lines in f-string.
new_line = '\n'

# an f-string prints the value of sin(π/2) by calling the taylor_expansion function.
print(f"{new_line}sin(π/2) = {taylor_expansion(k,numpy.pi/2):5f}  # taylor_expansion()")

# the average amount of time taken for the taylor_expansion function to run is printed.
# %timeit taylor_expansion(k,numpy.pi/2)

# an f-string prints the value of sin(π/2) using numpy.sin() function.
print(f"{new_line}sin(π/2) = {numpy.sin(numpy.pi/2):5f}  # numpy.sin()")

# the average amount of time taken for the numpy.sin() function to run is printed.
# %timeit numpy.sin(numpy.pi/2)

# Exercise 2

# function matrix_product is defined with input arguments a and b.
def matrix_product(a,b):
    """
    This function calculates the product of two matrices.

    Input argument:
    a: (list)    the first matrix in the multiplication.
    b: (list)    the second matrix in the multiplication.

    Returns:
    product: (list)    matrix equal to the product of matrices a and b.
    """
    # the if statement checks whether a and b have the same dimensions. if not, an error is returned.
    if len(a[0]) != len(b):
        print("the two matrices have different dimensions and cannot be multiplied.")
        return 0

    # 'product' is set to list with same amount of rows as a and same amount of columns as b, with items as zeros using list comprehension.
    product = [[0] * len(b[0]) for i in a]

    # the outer for loop iterates over the rows in the product matrix.
    for i in range(0,len(product)):
        # the first nested for loop iterates over the columns of the product matrix.
        for j in range(0,len(product[0])):
            # the second nested for loop iterates the same amount of times as the number of colums in a to calculate dot product.
            for k in range(len(a[0])):
                # each element in product matrix is set to the dot product between the corresponding row of a and column of b.
                product[i][j] += a[i][k] * b[k][j]

    # the final product matrix is returned.
    return product

# matrices a, b, c, d, e and f will be used to check whether the program works.

a = [[7,10],
     [9,9],
     [3,1]] # 3 x 2

b = [[1,2,3,3,5],
     [2,2,7,6,5]] # 2 x 5

c = [[1,1,2],
     [2,4,2],
     [1,5,1]] # 3 x 3

d = [[2,1,4],
     [3,3,1],
     [4,5,6]] # 3 x 3

e = [[9,3,4,5],
     [2,2,5,4],
     [2,7,6,5]] # 3 x 4

f = [[2,7],
     [9,2],
     [3,3],
     [4,2]] # 4 x 2

# 'new_line' is set to the string '\n' to make new lines in f-string.
new_line = '\n'

# an f-string is used to print the multiplication of different combinations of the matrices, all of which have the same dimensions.
print(
    f"Test:{new_line}{a} ⋅ {b} = {matrix_product(a,b)}{new_line}"
    f"{c} ⋅ {d} = {matrix_product(c,d)}{new_line}"
    f"{e} ⋅ {f} = {matrix_product(e,f)}{new_line}"
    f"{c} ⋅ {e} = {matrix_product(c,e)}{new_line}"
    f"{d} ⋅ {a} = {matrix_product(d,a)}{new_line}"
    f"{f} ⋅ {b} = {matrix_product(f,b)}{new_line}"
    )

# Bonus challenge v2

# the matrix_product function remains the same, calculating and returning the product of two matrices a and b.
def matrix_product(a,b):
    """
    This function calculates the product of two matrices.

    Input argument:
    a: (list)    the first matrix in the multiplication.
    b: (list)    the second matrix in the multiplication.

    Returns:
    product: (list)    matrix equal to the product of matrices a and b.
    """
    # the if statement checks whether a and b have the same dimensions. if not, an error is returned.
    if len(a[0]) != len(b):
        print("the two matrices have different dimensions and cannot be multiplied.")
        return 0

    # 'product' is set to list with same amount of rows as a and same amount of columns as b, with items as zeros using list comprehension.
    product = [[0] * len(b[0]) for i in a]

    # the outer for loop iterates over the rows in the product matrix.
    for i in range(0,len(product)):
        # the first nested for loop iterates over the columns of the product matrix.
        for j in range(0,len(product[0])):
            # the second nested for loop iterates the same amount of times as the number of colums in a to calculate dot product.
            for k in range(len(a[0])):
                # each element in product matrix is set to the dot product between the corresponding row of a and column of b.
                product[i][j] += a[i][k] * b[k][j]

    # the final product matrix is returned.
    return product

# a second function product_sequence is created, which takes a compilation of matrices stored in a list 'c' and calculates their product by calling the matrix_product function.
def product_sequence(c):
    """
    This function calculates the product of multiple matrices sequencially.

    Input argument:
    c: (list)    a list containing all matrices to be multiplied as items.

    Returns:
    product: (list)    matrix equal to the product of all matrices in c.
    """

    # variable 'product' is initially set to the first matrix in the list 'c'.
    product = c[0]

    # a for loop iterates from 1 to the number of matrices in 'c' minus 1.
    for p in range(1,len(c)):
        # after every iteration, the product is set to equal the 'product' matrix multiplied by the next matrix (as p increases) by using recursion with the matrix_product function.
        product = matrix_product(product,c[p])

    # the final product of all matrices is returned.
    return product

# to test the program, 'c' has been set to contain three matrices, all of which are compatible for multiplication.
c = [[[7,10],
     [9,9],
     [3,1]], # 3 x 2
     [[1,2,3,3,5],
     [2,2,7,6,5]], # 2 x 5
     [[1,1,2],
     [2,4,2],
     [1,5,1],
     [5,3,3],
     [2,1,2]]] # 5 x 3

# the matrix product of all matrices in 'c' is printed. A manual check of the answer confirms it is correct.
print(product_sequence(c))

# Exercise 3 part a)

# function fibonacci is defined with input arguement n.
def fibonacci(n):
    """
    This function calculates the nth term of the Fibonacci sequence.

    Input argument:
    n: (integer)    the nth term of the sequence.

    Returns:
    nth_term: (integer)    the value of the nth term in the sequence.
    """

    # if 'n' is 1 or 2, 1 is returned.
    if n == 1 or n == 2:
        return 1

    # otherwise, the value of the nth term is returned using recursion.
    else:
        return (fibonacci(n-1) + fibonacci(n-2))

# 'n' is set to the integer type of the user's input.
n = int(input("n = "))

# 'g' is set to an approximation of the golden ratio through equation 2.
# accuracy of 'g' is dependent upon the value of 'n' inputted by the user.
g = (fibonacci(n+1)/fibonacci(n))

# an f-string prints the value of g.
print(f"φ = {g}")

# an f-string prints the error by calculating the difference between g and the golden ratio.
print(f"error = {abs(((1+(5**(0.5)))/2)-g)}")

# Exercise 3 part b)

# function golden_ratio
def goldenRatio(n):
    """
    This function approximates the value of the golden ratio.

    Input argument:
    n: (integer)    the number of terms in the continued fraction.

    Returns:
    golden_ratio: (integer)    the calculated value of the golden ratio.
    """

    # if n is zero, 1 is returned.
    if n == 0:
        return 1

    # otherwise, recursion is used for the continued fraction to return the golden ratio.
    else:
        return (1 + (1/goldenRatio(n-1)))

# the value of the function goldenRatio() for n = 10 is stored in 'x'.
x = goldenRatio(10)

# 'new_line' is set to the string '\n' to make new lines in f-string.
new_line = '\n'

# the value stored in x is printed using an f-string.
print(f"For n = 10:{new_line}φ = {x}")

# the error of the value of x is printed by taking x's difference with the golden ratio.
print(f"error = {abs(((1+(5**(0.5)))/2)-x)}")

# Exercise 3 part c)

# 'n' is initially set to 1 outside the while loop.
n = 1

# a while loop with condition True is created.
while True:
    # if the corresponding 'n' gives the same value of x when used in equation 2, the loop is broken out of.
    if fibonacci(n+1)/fibonacci(n) == x:
        break
    # otherwise, 1 is added to n.
    else:
        n += 1

# the value of n is printed using an f-string.
print(f"n = {n}")

"""In part c) of Exercise 3, we have to find the value of n for which equation 2 would yield the same value as equation 3 when n = 10. Initially, n was set to 1 outside the while loop that will follow (n was not set to 0 since fibonacci(0) gives an error). Next, a while loop with condition True was created. In the while loop, an if statement would break out of the loop if the condition fibonacci(n+1)/fibonacci(n) == x is satisfied (equation 2) and the value of n for which the condition is true would be printed thereafter. If the condition is not satisfied with the current value of n, 1 is added to n and the loop is reiterated until the if statement is set off."""
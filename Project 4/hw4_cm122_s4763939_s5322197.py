# -*- coding: utf-8 -*-
"""HW4 CM122 s4763939 s5322197.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mURlMnYQbuwwcrT_7-rwhtGQuDIM6D2X
"""

# Exercise 1

# the necessary packages (matplotlib.pyplot and numpy) are imported.
import matplotlib.pyplot as plt
import numpy as np

# a function f is defined with input arguments a, b and c.
def f(a,b,c):
    """
    This function plots the function ax^2 + bx + c, marks the zeros with red dots, labels the axes, adds a title including the
    function presented and adjusts the range of the axes so that the intersection and extreme points are visible for every input.

    Input arguments:
    a: (float)  the coefficient of x^2.
    b: (float)  the coefficient of x.
    c: (float)  the coefficient with no x.

    Returns:
    graph: (function)   the graph of the function.
    """

    # if a is equal to zero, no output is returned from the function.
    if a == 0:
        return

    # D is set to equal the determinant. The amount of zeros is determined by the sign of D.
    D = b**2-4*a*c

    # If D is positive, the two zeros are defined and are added to the list 'zeros'.
    if D>0:
        x1=(-b-D**(1/2))/(2*a)
        x2=(-b+D**(1/2))/(2*a)
        zeros = [x1, x2]

    # If D = 0, one zero is defined and is added to the list 'zeros'.
    elif D==0:
        x1=-b/(2*a)
        zeros = [x1]

    # If D is negative, no zeros are defined and 'zeros' is set to an empty list.
    else:
        zeros = []

    # x is set to the linespace with a range of 5 units away from the nearest zero on each side.
    x = np.linspace(min(zeros)-5,max(zeros)+5,10000)

    # y is set to the quadratic equation with coeficients a, b and c.
    y = a*(x**2) + b*x + c

    # a linear grid is added to the graph.
    plt.grid()

    # a title of the function being graphed is shown in Latex, making use of conditional statements to show the conventional equation format.
    plt.title(f'Plot of ${"" if a == 1 else a}x^2 {"+ " if b > 0 else ""}{"- " if b < 0 else "" if b == 0 else ""}{f"{abs(b)}x" if b != 0 and abs(b) != 1 else ""}{"x" if abs(b) == 1 else ""} {"+ " if c > 0 else ""}{"- " if c < 0 else "" if c == 0 else ""}{abs(c) if c != 0 else ""}$')

    # the x-axis is labeled 'x'
    plt.xlabel('x')

    # the y-axis is labeled 'f(x)'
    plt.ylabel('f(x)')

    # a figure caption is added below the graph.
    plt.text(0.5, -0.25, 'Figure 1: Output of Exercise 1.', ha='center', fontsize=12, transform=plt.gca().transAxes)

    # the graph of x and y is plotted, marking the coordinates found in the list 'zeros' as red dots.
    plt.plot(x, y, zeros, [0]*len(zeros), 'ro')

    # plt.show() is returned to present the graph
    return plt.show()

# function f is called with input arguemnts a=1, b=0, c=-1.
f(1,0,-1)

# Exercise 2

# the necessary packages (matplotlib.pyplot and numpy) are imported.
import matplotlib.pyplot as plt
import numpy as np

# variable 'new_line' is set to the string '\n' to add new lines in an f-string.
new_line = '\n'

# a function 'next_n' is created with input argument 'current_n'.
def next_n(current_n):
    """
    This function returns the next number in the Collatz conjecture given a current number n.

    Input arguments:
    current_n: (integer)    current value of n.

    Returns:
    next_n: (integer)   the following value of n.
    """

    # if 'current_n' is even, 'current_n' divided by 2 is returned.
    if current_n % 2 == 0:
        return current_n//2
    # otherwise ('current_n' is odd), 3 times 'current_n' plus 1 is returned.
    else:
        return 3*current_n + 1

# a function collatz is defined with input arguments 'm' and 'k'.
def collatz(m,k):
    """
    This function makes use of the next_n function to graph the Collatz conjecture for m powers of 10 in subplots.

    Input arguments:
    m: (integer)    the amount of subplots to be presented.
    k: (integer)    the amount of columns used to present the subplots with.

    Returns:
    m subplots of the Collatz conjecture with k columns.
    """

    # a set of m subplots with k columns is created.
    my_figure, my_axes = plt.subplots(m//k, k, figsize=(8,8), constrained_layout=True)

    # a for loop is created to iterate over every subplot.
    for i in range(m):
        # n is set to 10 to the power of i plus 1 (since i starts at zero).
        n = 10**(i+1)
        # y is set to a list with element 'n' previously defined.
        y = [n]

        # a while loop with condition n is not equal to 1 is created.
        while n != 1:
            # for each iteration, n is set to the next number in the collatz sequence by calling the next_n function with argument 'n'.
            n = next_n(n)
            # the new number 'n' has been set to is appended to the list 'y'.
            y.append(n)

        # if the maximum value in the sequence is greater than 10 to the power of the number of columns 'k', the graph is set to logarithmic.
        if max(y) > 10**k:
            # the y scale is set to logarithmic.
            my_axes[i//k,i%k].set_yscale('log')
            # a title of the sequence is added, also stating that the graph is logarithmic.
            my_axes[i//k,i%k].set_title(f"3x+1 series of 10^{i+1},{new_line}with a stopping time of {len(y)-1} steps. Log scale")
            # logarithmic gridlines are added to the graph.
            my_axes[i//k,i%k].grid(which="both")

        # Otherwise, the graphs are set to linear graphs.
        else:
            # a title of the sequence is added.
            my_axes[i//k,i%k].set_title(f"3x+1 series of 10^{i+1},{new_line}with a stopping time of {len(y)-1} steps.")
            # linear gridlines are added to the graph.
            my_axes[i//k,i%k].grid()

        # for all graphs:

        # the x-axis label is set to 'Sequence element'.
        my_axes[i//k,i%k].set_xlabel('Sequence element')
        # the y-axis label is set to 'Sequence value'.
        my_axes[i//k,i%k].set_ylabel('Sequence value')
        # the subplot is plotted.
        my_axes[i//k,i%k].plot(y, label=f'max num = {max(y)}')
        # a legend is added with the maximum number in the sequence.
        my_axes[i//k,i%k].legend()

# the collatz function is called with input arguments m=4 and k=2.
collatz(4,2)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle

# a function E_at is created with input arguments x, y, q and r0.
def E_at(x,y,q,r0):
    # variable 'x0' is set to a list with the same dimensions as 'r0' filled with zeros.
    x0=r0[0]
    # variable 'y0' is set to a list with the same dimensions as 'r0' filled with ones.
    y0=r0[1]
    # the electric field components are calculated at a given point.
    Ex=q*(x-x0)/np.sqrt((x-x0)**2+(y-y0)**2)
    Ey=q*(y-y0)/np.sqrt((x-x0)**2+(y-y0)**2)
    # the calculated electric field components are returned.
    return (Ex,Ey)

# variable 'n' is set to equal 40.
n=40
# 'x' and 'y' are set to the linespace from -4 to 4.
x=np.linspace(-4,4,n)
y=np.linspace(-4,4,n)
# a coordinate system for x and y is created.
x,y=np.meshgrid(x,y)

# variables of the electric field before the addition of charges are defined.
E_on_x=np.zeros((n,n))
E_on_y=np.zeros((n,n))

# variable 'Nq' is set to the integer type of the user's input.
Nq=int(input('Nq: '))
# 'qs' is initially set to an empty list.
qs=[]

# a for loop that interates 'Nq' number of times is created.
for i in range(Nq):
    # q is set to alternate between -1 and 1 between each iteration.
    q=(-1)**i
    # variables 'x0' and 'y0' are redefined for each iteration.
    x0=np.cos(2*np.pi*i/Nq)
    y0=np.sin(2*np.pi*i/Nq)
    # the value of q (-1 or 1) as well as the values of 'x0' and 'y0' are appended to qs for each iteration.
    qs.append((q,x0,y0)) # creating the list of charges with their coordinates

# a for loop iterates over the list 'qs'.
for i in qs:
    # the field components generated by each individual charge are added.
    E_on_x=E_on_x+E_at(x,y,i[0],[i[1],i[2]])[0]
    E_on_y=E_on_y+E_at(x,y,i[0],[i[1],i[2]])[1]

plt.figure(dpi=1000)
# plots the arrow field with arrows having Ex and Ey components at every x and y.
plt.quiver(x,y,E_on_x,E_on_y,)
# makes the plotting area square for aesthetic purposes.
plt.axis('square')
# a grid is added to the graph.
plt.grid()
# x and y axis labels are added.
plt.xlabel('x')
plt.ylabel('y')
# a graph title is added.
plt.title('Electric field of '+str(Nq)+' charges')

# a for loop that iterates over the list 'qs' is created.
for i in qs:
    # if and else statements determine what colour to assign to the circle based on the charge.
    if i[0]==1:
        colour='blue'
    else:
        colour='red'
    plt.gca().add_patch(plt.Circle((i[1],i[2]),0.2, fc=colour)) # draws a circle at the position of the charge of the colour established previously